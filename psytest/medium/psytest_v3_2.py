""" Улучшается интерфейс: показывается только одна альтернатива, а не все вместе 
Для работы кнопок перехода добавляются нужные методы и соединяются с сигналами
При нажатии на "далее" выполняется функция 
next_click(), которая вызывает или show_result (если опросник закончился), или "перелистывает" опросник вперед.

При нажатии "назад" - опросник перелистывается назад.

Объекту класса AlternativeGroup, соответственно, нужны методы:
- is_last()  : определить, что опросник закончился
- next_q()   : "перелистывание вперед" (переход к следующей паре вариантов)
- prev_q()   : "перелистывание назад" (если есть предыдущий вопрос, показывает его) 
- results()  : это была отдельная функция, но ей нужно работать со списком панелей, поэтому она стала методом класса
для работы next_q и prev_q нужны методы
- show_curr() : показать текущую панель с вопросами 
- hide_curr() : спрятать (прежде чем показать другую)

"""

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication, QWidget, QHBoxLayout, QVBoxLayout,
    QGroupBox, QRadioButton, QPushButton, QLabel)

# типы профессий ("психологические профили", по которым человек может сориентироваться в будущей професии)
prf_types = [
    ' «Человек—природа» — все профессии, связанные с растениеводством, животноводством и лесным хозяйством. ',
    ' «Человек—техника» — все технические профессии. ',
    ' «Человек—человек» — все профессии, связанные с обслуживанием людей, с общением. ',
    '«Человек—знак» — все профессии, связанные с обсчетами, цифровыми буквенными знаками, в том числе и музыкальные '
    'специальности. ',
    ' «Человек—художественный образ» — все творческие специальности. '
]
# список вопросов (альтернатив). В списке используются номера, чтобы было проще найти ключ к каждому вопросу
# (в статьях, по которым пишется программа, ключи даны в виде отдельной таблицы с указанием номеров вопросов).
# Ключи взяты из источников по опроснику Климов и вписаны прямо в этот же список:
# после каждой альтернативы указан номер типа профессии в списке выше   
test_choices = [
    (1, 'Ухаживать за животными', 0, 'Обслуживать машины', 1),
    (2, 'Помогать больным людям, лечить их', 2, 'Составлять таблицы, схемы, программы для вычислительных машин', 3),
    (3, 'Участвовать в оформлении книг, плакатов,  журналов', 4, 'Следить за состоянием и развитием растений', 0),
    (4, 'Обрабатывать материалы (древесину, ткань, металл, пластмассу и др.)', 1,
     'Доводить товары до потребителя (рекламировать)', 2),
    (5, ' Обсуждать научно-популярные книги, статьи', 3, 'Обсуждать художественные книги (или пьесы, концерты)', 4),
    (6, 'Содержать животных', 0,
     'Тренировать товарищей (или младших школьников) в выполнении каких-либо действий (трудовых, учебных, спортивных)',
     2),
    (7, 'Копировать рисунки, изображения (или настраивать музыкальные инструменты)', 4,
     'Управлять подъемным краном, трактором, тепловозом и т. п.', 1),
    (8, 'Сообщать (разъяснять) людям какие-либо сведения (в справочном бюро, на экскурсии)', 2,
     'Художественно оформлять выставки, витрины (или участвовать в подготовке пьес, концертов)', 4),
    (9, 'Ремонтировать вещи (одежду, технику), жилище', 1, 'Искать и исправлять ошибки в текстах, таблицах, рисунках',
     3),
    (10, 'Лечить животных', 0, 'Выполнять вычисления, расчеты', 3),
]


class AlternativeGroup():
    """ объект хранит группу с двумя радио-кнопками, т.е. это два варианта утверждений в одном вопросе"""

    def __init__(self, number):
        """ конструктор жестко привязан к списку test_choices, он берёт из него запись с номером number и использует
        для наполнения информацией """
        # переданный номер должен соответствовать какому-то индексу, иначе ничего не делаем
        if 0 <= number < len(test_choices):
            dataset = test_choices[number]  # берем запись с номером number
            # разбираем эту информацию на отдельные элементы: 
            num_to_show = dataset[0]  # это - номер вопроса на экране
            answer1 = dataset[1]  # это - первая альтернатива
            self.type1 = dataset[2]  # тип профессии, который будет выбран, если выделена первая альтернатива
            # нам потребуется помнить эту информацию, поэтому берем не просто в переменную,
            # а в свойство экземпляра
            answer2 = dataset[3]  # то же со второй альтернативой
            self.type2 = dataset[4]

            # теперь создаем виджеты и запоминаем нужные свойства:
            self.number = number
            self.group = QGroupBox(' Вопрос ' + str(num_to_show))  # группа
            self.a1 = QRadioButton(answer1)  # вариант 1
            self.a2 = QRadioButton(answer2)  # вариант 2
            # размещение в строку
            layoutH = QHBoxLayout()
            layoutH.addWidget(self.a1, alignment=Qt.AlignHCenter)
            layoutH.addWidget(self.a2, alignment=Qt.AlignHCenter)
            self.group.setLayout(layoutH)  # строка с переключателями - макет для группы 

    def value(self):
        """ узнаем, какой тип профессии выбран"""
        val = -1  # значит, ничего не выбрано
        if self.a1.isChecked():
            val = self.type1
        if self.a2.isChecked():
            val = self.type2
        return val


class AllQuestions(QWidget):
    """ Виджет, в котором показывается только одна панель с двумя вариантами на выбор
    Остальные панели (экземпляры AlternativeGroup) создаются, но прячутся"""

    def __init__(self):
        super().__init__()
        layoutV = QVBoxLayout()  # все вопросы будут расположены в столбец
        self.groups = []  # список созданных объектов. Его нужно помнить как свойство!
        i = 0
        while i < len(test_choices):
            a_group = AlternativeGroup(i)
            layoutV.addWidget(a_group.group)  # объект a_group просто объединяет виджеты. 
            # Нам надо добавить в макет конкретно GroupBox, т.е. свойство group
            a_group.group.hide()  # все GroupBox'ы при добавлении прячем и будем следить за тем, чтобы
            # показывался только один виджет
            self.groups.append(a_group)
            i += 1
        self.setLayout(layoutV)
        self.current_choice = 0  # в этом свойстве храним номер того вопроса, который сейчас показывается
        self.show_curr()  # покажем нулевой вопрос

    def is_last(self):
        """ возвращает True, если текущий вопрос - последний в списке
        (и тогда кнопка "далее" переводит к показу результатов)"""
        # это равенство - нужное нам условие, его значением будет True или False
        return self.current_choice + 1 == len(self.groups)

    def show_curr(self):
        """ показывает текущую панель"""
        a_group = self.groups[self.current_choice]
        a_group.group.show()

    def hide_curr(self):
        """ скрывает текущую панель"""
        a_group = self.groups[self.current_choice]
        a_group.group.hide()

    def next_q(self):
        """ показывает следующий вопрос"""
        if not self.is_last():
            self.hide_curr()  # скрыли
            self.current_choice += 1  # перешли к следующей
            self.show_curr()  # показали

    def prev_q(self):
        """ показывает предыдущий вопрос"""
        if self.current_choice > 0:
            self.hide_curr()  # скрыли
            self.current_choice -= 1  # перешли назад
            self.show_curr()  # показали

    def results(self):
        """ возвращает строку, описывающую выбранный тип профессии """
        # (это теперь метод объекта AllQuestions)
        # посчитаем, сколько ответов каждого типа мы получили:
        type_answers = [0, 0, 0, 0, 0]
        # у нас ровно столько же prf_types, сколько и в этом списке
        # мы на нужных местах этого списка ведем подсчет количества ответов, а потом посмотрим в  
        # список prf_types, что там на соответствующем месте

        for a_group in self.groups:
            v = a_group.value()  # если что-то выбрано, то получим номер типа профессии, иначе -1
            if v > -1:
                type_answers[v] += 1  # добавим единицу к счетчику того типа профессии, номер которого выбран

        # теперь посчитаем максимум и заодно выберем нужную строку из prf_types
        max_ta = -1
        txt = ''
        i = 0
        while i < len(type_answers):
            if type_answers[i] > max_ta:
                max_ta = type_answers[i]  # нашли новый максимум
                txt = prf_types[i]  # взяли текстовое описание типа профессии по номеру в списке
            i += 1

        return txt  # готово


def show_result():
    """ функция работает по нажатию на кнопку, показывает результат: какие профессии посоветуем тестируемому """
    text = questionnary.results()  # получили текстовое описание победившей группы профессий
    # теперь окно с ответом
    global w_answer  # окно должно остаться после функции
    w_answer = QWidget()
    answer = QLabel(text)  # надпись будем показывать в окне.
    layout = QVBoxLayout()
    layout.addWidget(answer, alignment=Qt.AlignCenter)
    w_answer.setLayout(layout)
    w_answer.setWindowTitle('Результат')
    w_answer.resize(800, 300)
    w_answer.show()


def next_click():
    if questionnary.is_last():
        show_result()
    else:
        questionnary.next_q()


# Теперь создаем основное окно 
app = QApplication([])
main_w = QWidget()
main_w.resize(800, 200)
main_w.setWindowTitle('Опросник')

btn_prev = QPushButton('Назад')
btn_next = QPushButton('Далее')

layoutH = QHBoxLayout()
layoutV = QVBoxLayout()

layoutH.addWidget(btn_prev)
layoutH.addWidget(btn_next)

questionnary = AllQuestions()  # создали виджет со всеми вопросами

layoutV.addWidget(questionnary)  # добавим виджет и кнопки под ним
layoutV.addLayout(layoutH)
main_w.setLayout(layoutV)

# связали нажатия на кнопки и соответствующие функции:
btn_next.clicked.connect(next_click)
btn_prev.clicked.connect(questionnary.prev_q)

# запускаем:
main_w.show()
app.exec()
