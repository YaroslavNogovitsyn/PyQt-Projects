""" Вариант опросника со списками
Списки используются и для функции show_result
"""

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QApplication, QWidget, QHBoxLayout, QVBoxLayout,
    QGroupBox, QRadioButton, QPushButton, QLabel)

# типы профессий ("психологические профили", по которым человек может сориентироваться в будущей професии)
prf_types = [
    ' «Человек—природа» — все профессии, связанные с растениеводством, животноводством и лесным хозяйством. ',
    ' «Человек—техника» — все технические профессии. ',
    ' «Человек—человек» — все профессии, связанные с обслуживанием людей, с общением. ',
    '«Человек—знак» — все профессии, связанные с обсчетами, цифровыми буквенными знаками, в том числе и музыкальные '
    'специальности. ',
    ' «Человек—художественный образ» — все творческие специальности. '
]
# список вопросов (альтернатив). В списке используются номера, чтобы было проще найти ключ к каждому вопросу
# (в статьях, по которым пишется программа, ключи даны в виде отдельной таблицы с указанием номеров вопросов).
# Ключи взяты из источников по опроснику Климов и вписаны прямо в этот же список:
# после каждой альтернативы указан номер типа профессии в списке выше   
test_choices = [
    (1, 'Ухаживать за животными', 0, 'Обслуживать машины', 1),
    (2, 'Помогать больным людям, лечить их', 2, 'Составлять таблицы, схемы, программы для вычислительных машин', 3),
    (3, 'Участвовать в оформлении книг, плакатов,  журналов', 4, 'Следить за состоянием и развитием растений', 0),
    (4, 'Обрабатывать материалы (древесину, ткань, металл, пластмассу и др.)', 1,
     'Доводить товары до потребителя (рекламировать)', 2),
    (5, ' Обсуждать научно-популярные книги, статьи', 3, 'Обсуждать художественные книги (или пьесы, концерты)', 4),
    (6, 'Содержать животных', 0,
     'Тренировать товарищей (или младших школьников) в выполнении каких-либо действий (трудовых, учебных, спортивных)',
     2),
    (7, 'Копировать рисунки, изображения (или настраивать музыкальные инструменты)', 4,
     'Управлять подъемным краном, трактором, тепловозом и т. п.', 1),
    (8, 'Сообщать (разъяснять) людям какие-либо сведения (в справочном бюро, на экскурсии)', 2,
     'Художественно оформлять выставки, витрины (или участвовать в подготовке пьес, концертов)', 4),
    (9, 'Ремонтировать вещи (одежду, технику), жилище', 1, 'Искать и исправлять ошибки в текстах, таблицах, рисунках',
     3),
    (10, 'Лечить животных', 0, 'Выполнять вычисления, расчеты', 3),
]


class AlternativeGroup:
    """ объект хранит группу с двумя радио-кнопками, т.е. это два варианта утверждений в одном вопросе"""

    def __init__(self, number):
        """ конструктор жестко привязан к списку test_choices, он берёт из него запись с номером number и использует
        для наполнения информацией """
        # переданный номер должен соответствовать какому-то индексу, иначе ничего не делаем
        if 0 <= number < len(test_choices):
            dataset = test_choices[number]  # берем запись с номером number
            # разбираем эту информацию на отдельные элементы: 
            num_to_show = dataset[0]  # это - номер вопроса на экране
            answer1 = dataset[1]  # это - первая альтернатива
            self.type1 = dataset[2]  # тип профессии, который будет выбран, если выделена первая альтернатива
            # нам потребуется помнить эту информацию, поэтому берем не просто в переменную,
            # а в свойство экземпляра
            answer2 = dataset[3]  # то же со второй альтернативой
            self.type2 = dataset[4]

            # теперь создаем виджеты и запоминаем нужные свойства:
            self.number = number
            self.group = QGroupBox(' Вопрос ' + str(num_to_show))  # группа
            self.a1 = QRadioButton(answer1)  # вариант 1
            self.a2 = QRadioButton(answer2)  # вариант 2
            # размещение в строку
            layoutH = QHBoxLayout()
            layoutH.addWidget(self.a1, alignment=Qt.AlignHCenter)
            layoutH.addWidget(self.a2, alignment=Qt.AlignHCenter)
            self.group.setLayout(layoutH)  # строка с переключателями - макет для группы 

    def value(self):
        """ узнаем, какой тип профессии выбран"""
        val = -1  # значит, ничего не выбрано
        if self.a1.isChecked():
            val = self.type1
        if self.a2.isChecked():
            val = self.type2
        return val


def results():
    """ функция возвращает строку, описывающую выбранный тип профессии """
    # посчитаем, сколько ответов каждого типа мы получили:
    type_answers = [0, 0, 0, 0, 0]
    # у нас ровно столько же prf_types, сколько и в этом списке
    # мы на нужных местах этого списка ведем подсчет количества ответов, а потом посмотрим в  
    # список prf_types, что там на соответствующем месте

    for a_group in groups:
        v = a_group.value()  # если что-то выбрано, то получим номер типа профессии, иначе -1
        if v > -1:
            type_answers[v] += 1  # добавим единицу к счетчику того типа профессии, номер которого выбран

    # теперь посчитаем максимум и заодно выберем нужную строку из prf_types
    max_ta = -1
    txt = ''
    i = 0
    while i < len(type_answers):
        if type_answers[i] > max_ta:
            max_ta = type_answers[i]  # нашли новый максимум
            txt = prf_types[i]  # взяли текстовое описание типа профессии по номеру в списке
        i += 1

    return txt  # готово


def show_result():
    """ функция работает по нажатию на кнопку, показывает результат: какие профессии посоветуем тестируемому """
    text = results()  # получили текстовое описание победившей группы профессий
    # теперь окно с ответом
    global answer  # окно должно остаться после функции
    answer = QLabel(text)  # лень расставлять надписи в окне, сделаем просто надпись-окно.
    answer.resize(800, 300)
    answer.show()  # done.


# Теперь используем созданный класс и списки, чтобы показать на экране окно с вариантами. 
app = QApplication([])

layoutV = QVBoxLayout()  # все вопросы будут расположены в столбец
groups = []  # список созданных объектов. Сейчас начнем создавать:
i = 0
while i < len(test_choices):
    a_group = AlternativeGroup(i)
    layoutV.addWidget(a_group.group)  # объект a_group просто объединяет виджеты. 
    # Нам надо добавить в макет конкретно GroupBox, т.е. свойство group
    groups.append(a_group)
    i += 1

# осталось создать основное окно:
main_w = QWidget()
main_w.setWindowTitle('Опросник')
btn_done = QPushButton('Готово!')
layoutV.addWidget(btn_done)  # добавили к куче вопросов кнопку
main_w.setLayout(layoutV)  # и этот макет теперь соответствует нашему окну
# связали нажатие на кнопку и функцию:
btn_done.clicked.connect(show_result)

# запускаем:
main_w.show()
app.exec()
